{"version":3,"sources":["../webpack/bootstrap",".././src/extension.js",".././src/util.js","../external \"os\"","../external \"vscode\""],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,WAAW,mBAAO,CAAC,6BAAQ;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6CAA6C;AAC7C;AACA,aAAa;;AAEb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA,kDAAkD;AAClD;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;;AAEA;AACA;AACA,2BAA2B,2BAA2B;AACtD,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzLA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,SAAS,mBAAO,CAAC,cAAI;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA,oCAAoC,UAAU;AAC9C;AACA,0BAA0B;;AAE1B;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,wCAAwC;AACxC;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA,UAAU,yBAAyB;AACnC;AACA;;AAEA;;AAEA;AACA,iEAAiE,KAAK;AACtE;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,sBAAsB,4BAA4B;AAClD;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,gBAAgB;;AAEvC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;;AAEb;;AAEA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,KAAK,GAAG,IAAI;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,EAAE,cAAc,EAAE,mDAAmD;AACjG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtSA,+B;;;;;;;;;;;ACAA,mC","file":"extension.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/extension.js\");\n","/**\n * vscode plugin for highlighting TODOs and FIXMEs within your code\n *\n * NOTE: each decoration type has a unique key, the highlight and clear highight functionality are based on it\n */\n\nvar vscode = require('vscode');\nvar util = require('./util');\nvar window = vscode.window;\nvar workspace = vscode.workspace;\n\nfunction activate(context) {\n\n    var timeout = null;\n    var activeEditor = window.activeTextEditor;\n    var isCaseSensitive, assembledData, decorationTypes, pattern, styleForRegExp, keywordsPattern;\n    var workspaceState = context.workspaceState;\n\n    var settings = workspace.getConfiguration('todohighlight');\n\n    init(settings);\n\n    context.subscriptions.push(vscode.commands.registerCommand('todohighlight.toggleHighlight', function () {\n        settings.update('isEnable', !settings.get('isEnable'), true).then(function () {\n            triggerUpdateDecorations();\n        });\n    }))\n\n    context.subscriptions.push(vscode.commands.registerCommand('todohighlight.listAnnotations', function () {\n        if (keywordsPattern.trim()) {\n            util.searchAnnotations(workspaceState, pattern, util.annotationsFound);\n        } else {\n            if (!assembledData) return;\n            var availableAnnotationTypes = Object.keys(assembledData);\n            availableAnnotationTypes.unshift('ALL');\n            util.chooseAnnotationType(availableAnnotationTypes).then(function (annotationType) {\n                if (!annotationType) return;\n                var searchPattern = pattern;\n                if (annotationType != 'ALL') {\n                    annotationType = util.escapeRegExp(annotationType);\n                    searchPattern = new RegExp(annotationType, isCaseSensitive ? 'g' : 'gi');\n                }\n                util.searchAnnotations(workspaceState, searchPattern, util.annotationsFound);\n            });\n        }\n    }));\n\n    context.subscriptions.push(vscode.commands.registerCommand('todohighlight.showOutputChannel', function () {\n        var annotationList = workspaceState.get('annotationList', []);\n        util.showOutputChannel(annotationList);\n    }));\n\n    if (activeEditor) {\n        triggerUpdateDecorations();\n    }\n\n    window.onDidChangeActiveTextEditor(function (editor) {\n        activeEditor = editor;\n        if (editor) {\n            triggerUpdateDecorations();\n        }\n    }, null, context.subscriptions);\n\n    workspace.onDidChangeTextDocument(function (event) {\n        if (activeEditor && event.document === activeEditor.document) {\n            triggerUpdateDecorations();\n        }\n    }, null, context.subscriptions);\n\n    workspace.onDidChangeConfiguration(function () {\n        settings = workspace.getConfiguration('todohighlight');\n\n        //NOTE: if disabled, do not re-initialize the data or we will not be able to clear the style immediatly via 'toggle highlight' command\n        if (!settings.get('isEnable')) return;\n\n        init(settings);\n        triggerUpdateDecorations();\n    }, null, context.subscriptions);\n\n    function updateDecorations() {\n\n        if (!activeEditor || !activeEditor.document) {\n            return;\n        }\n\n        var text = activeEditor.document.getText();\n        var matches = {}, match;\n        while (match = pattern.exec(text)) {\n            var startPos = activeEditor.document.positionAt(match.index);\n            var endPos = activeEditor.document.positionAt(match.index + match[0].length);\n\n            var decoration = {\n                range: new vscode.Range(startPos, endPos)\n            };\n\n            var matchedValue = match[0];\n            let patternIndex = match.slice(1).indexOf(matchedValue);\n            matchedValue = Object.keys(decorationTypes)[patternIndex] || matchedValue;\n\n            if (!isCaseSensitive) {\n                matchedValue = matchedValue.toUpperCase();\n            }\n\n            if (matches[matchedValue]) {\n                matches[matchedValue].push(decoration);\n            } else {\n                matches[matchedValue] = [decoration];\n            }\n\n            if (keywordsPattern.trim() && !decorationTypes[matchedValue]) {\n                decorationTypes[matchedValue] = window.createTextEditorDecorationType(styleForRegExp);\n            }\n        }\n\n        Object.keys(decorationTypes).forEach(v => {\n            var rangeOption = settings.get('isEnable') && matches[v] ? matches[v] : [];\n            var decorationType = decorationTypes[v];\n            activeEditor.setDecorations(decorationType, rangeOption);\n        })\n    }\n\n    function init(settings) {\n        var customDefaultStyle = settings.get('defaultStyle');\n        keywordsPattern = settings.get('keywordsPattern');\n        isCaseSensitive = settings.get('isCaseSensitive', true);\n\n        if (!window.statusBarItem) {\n            window.statusBarItem = util.createStatusBarItem();\n        }\n        if (!window.outputChannel) {\n            window.outputChannel = window.createOutputChannel('TodoHighlight');\n        }\n\n        decorationTypes = {};\n\n        if (keywordsPattern.trim()) {\n            styleForRegExp = Object.assign({}, util.DEFAULT_STYLE, customDefaultStyle, {\n                overviewRulerLane: vscode.OverviewRulerLane.Right\n            });\n\n            pattern = keywordsPattern;\n        } else {\n            assembledData = util.getAssembledData(settings.get('keywords'), customDefaultStyle, isCaseSensitive);\n            Object.keys(assembledData).forEach((v) => {\n                if (!isCaseSensitive) {\n                    v = v.toUpperCase()\n                }\n\n                var mergedStyle = Object.assign({}, {\n                    overviewRulerLane: vscode.OverviewRulerLane.Right\n                }, assembledData[v]);\n\n                if (!mergedStyle.overviewRulerColor) {\n                    // use backgroundColor as the default overviewRulerColor if not specified by the user setting\n                    mergedStyle.overviewRulerColor = mergedStyle.backgroundColor;\n                }\n\n                decorationTypes[v] = window.createTextEditorDecorationType(mergedStyle);\n            });\n\n            // Give each keyword a group in the pattern\n            pattern = Object.keys(assembledData).map((v) => {\n                if (!assembledData[v].regex) {\n                    return `(${util.escapeRegExp(v)})`;\n                }\n\n                let p = assembledData[v].regex.pattern || v;\n                // Ignore unescaped parantheses to avoid messing with our groups\n                return `(${util.escapeRegExpGroups(p)})`\n            }).join('|');\n        }\n\n        pattern = new RegExp(pattern, 'gi');\n        if (isCaseSensitive) {\n            pattern = new RegExp(pattern, 'g');\n        }\n\n    }\n\n    function triggerUpdateDecorations() {\n        timeout && clearTimeout(timeout);\n        timeout = setTimeout(updateDecorations, 0);\n    }\n}\n\nexports.activate = activate;\n","var vscode = require('vscode');\nvar os = require(\"os\");\nvar window = vscode.window;\nvar workspace = vscode.workspace;\n\nvar defaultIcon = '$(checklist)';\nvar zapIcon = '$(zap)';\nvar defaultMsg = '0';\n\nvar DEFAULT_KEYWORDS = {\n    \"TODO:\": {\n        text: \"TODO:\",\n        color: '#fff',\n        backgroundColor: '#ffbd2a',\n        overviewRulerColor: 'rgba(255,189,42,0.8)'\n    },\n    \"FIXME:\": {\n        text: \"FIXME:\",\n        color: '#fff',\n        backgroundColor: '#f06292',\n        overviewRulerColor: 'rgba(240,98,146,0.8)'\n    }\n};\n\nvar DEFAULT_STYLE = {\n    color: \"#2196f3\",\n    backgroundColor: \"#ffeb3b\",\n};\n\nfunction getAssembledData(keywords, customDefaultStyle, isCaseSensitive) {\n    var result = {}, regex = [], reg;\n    keywords.forEach((v) => {\n        v = typeof v == 'string' ? { text: v } : v;\n        var text = v.text;\n        if (!text) return;//NOTE: in case of the text is empty\n\n        if (!isCaseSensitive) {\n            text = text.toUpperCase();\n        }\n\n        if (text == 'TODO:' || text == 'FIXME:') {\n            v = Object.assign({}, DEFAULT_KEYWORDS[text], v);\n        }\n        result[text] = Object.assign({}, DEFAULT_STYLE, customDefaultStyle, v);\n\n        if (v.regex) {\n            regex.push(regex.pattern||text);\n        }\n    })\n\n    if (regex) {\n        reg = regex.join('|');\n    }\n\n    // Don't override existing regex keywords with matching defaults\n    Object.keys(DEFAULT_KEYWORDS).filter(v => {\n        if (reg) {\n            if (v.match(new RegExp(reg))) {\n                return false;\n            }\n        }\n\n        return true;\n    }).forEach(v => {\n        if (!result[v]) {\n            result[v] = Object.assign({}, DEFAULT_STYLE, customDefaultStyle, DEFAULT_KEYWORDS[v]);\n        }\n    });\n\n    return result;\n}\n\nfunction chooseAnnotationType(availableAnnotationTypes) {\n    return window.showQuickPick(availableAnnotationTypes, {});\n}\n\n//get the include/exclude config\nfunction getPathes(config) {\n    return Array.isArray(config) ?\n        '{' + config.join(',') + '}'\n        : (typeof config == 'string' ? config : '');\n}\n\nfunction searchAnnotations(workspaceState, pattern, callback) {\n\n    var settings = workspace.getConfiguration('todohighlight');\n    var includePattern = getPathes(settings.get('include')) || '{**/*}';\n    var excludePattern = getPathes(settings.get('exclude'));\n    var limitationForSearch = settings.get('maxFilesForSearch', 5120);\n\n    var statusMsg = ` Searching...`;\n\n    window.processing = true;\n\n    setStatusMsg(zapIcon, statusMsg);\n\n    workspace.findFiles(includePattern, excludePattern, limitationForSearch).then(function (files) {\n\n        if (!files || files.length === 0) {\n            callback({ message: 'No files found' });\n            return;\n        }\n\n        var totalFiles = files.length,\n            progress = 0,\n            times = 0,\n            annotations = {},\n            annotationList = [];\n\n        function file_iterated() {\n            times++;\n            progress = Math.floor(times / totalFiles * 100);\n\n            setStatusMsg(zapIcon, progress + '% ' + statusMsg);\n\n            if (times === totalFiles || window.manullyCancel) {\n                window.processing = true;\n                workspaceState.update('annotationList', annotationList);\n                callback(null, annotations, annotationList);\n            }\n        }\n\n        for (var i = 0; i < totalFiles; i++) {\n\n            workspace.openTextDocument(files[i]).then(function (file) {\n                searchAnnotationInFile(file, annotations, annotationList, pattern);\n                file_iterated();\n            }, function (err) {\n                errorHandler(err);\n                file_iterated();\n            });\n\n        }\n        \n    }, function (err) {\n        errorHandler(err);\n    });\n}\n\nfunction searchAnnotationInFile(file, annotations, annotationList, regexp) {\n    var fileInUri = file.uri.toString();\n    var pathWithoutFile = fileInUri.substring(7, fileInUri.length);\n\n    for (var line = 0; line < file.lineCount; line++) {\n        var lineText = file.lineAt(line).text;\n        var match = lineText.match(regexp);\n        if (match !== null) {\n            if (!annotations.hasOwnProperty(pathWithoutFile)) {\n                annotations[pathWithoutFile] = [];\n            }\n            var content = getContent(lineText, match);\n            if (content.length > 500) {\n                content = content.substring(0, 500).trim() + '...';\n            }\n            var locationInfo = getLocationInfo(fileInUri, pathWithoutFile, lineText, line, match);\n\n            var annotation = {\n                uri: locationInfo.uri,\n                label: content,\n                detail: locationInfo.relativePath,\n                lineNum: line,\n                fileName: locationInfo.absPath,\n                startCol: locationInfo.startCol,\n                endCol: locationInfo.endCol\n            };\n            annotationList.push(annotation);\n            annotations[pathWithoutFile].push(annotation);\n        }\n    }\n}\n\nfunction annotationsFound(err, annotations, annotationList) {\n    if (err) {\n        console.log('todohighlight err:', err);\n        setStatusMsg(defaultIcon, defaultMsg);\n        return;\n    }\n\n    var resultNum = annotationList.length;\n    var tooltip = resultNum + ' result(s) found';\n    setStatusMsg(defaultIcon, resultNum, tooltip);\n    showOutputChannel(annotationList);\n}\n\nfunction showOutputChannel(data) {\n    if (!window.outputChannel) return;\n    window.outputChannel.clear();\n\n    if (data.length === 0) {\n        window.showInformationMessage('No results');\n        return;\n    }\n\n    var settings = workspace.getConfiguration('todohighlight');\n    var toggleURI = settings.get('toggleURI', false);\n\n    data.forEach(function (v, i) {\n        // due to an issue of vscode(https://github.com/Microsoft/vscode/issues/586), in order to make file path clickable within the output channel,the file path differs from platform\n        var patternA = '#' + (i + 1) + '\\t' + v.uri + '#' + (v.lineNum + 1);\n        var patternB = '#' + (i + 1) + '\\t' + v.uri + ':' + (v.lineNum + 1) + ':' + (v.startCol + 1);\n        var patterns = [patternA, patternB];\n\n        //for windows and mac\n        var patternType = 0;\n        if (os.platform() == \"linux\") {\n            // for linux\n            patternType = 1;\n        }\n        if (toggleURI) {\n            //toggle the pattern\n            patternType = +!patternType;\n        }\n        window.outputChannel.appendLine(patterns[patternType]);\n        window.outputChannel.appendLine('\\t' + v.label + '\\n');\n    });\n    window.outputChannel.show();\n}\n\nfunction getContent(lineText, match) {\n    return lineText.substring(lineText.indexOf(match[0]), lineText.length);\n};\n\nfunction getLocationInfo(fileInUri, pathWithoutFile, lineText, line, match) {\n    var rootPath = workspace.rootPath + '/';\n    var outputFile = pathWithoutFile.replace(rootPath, '');\n    var startCol = lineText.indexOf(match[0]);\n    var endCol = lineText.length;\n    var location = outputFile + ' ' + (line + 1) + ':' + (startCol + 1);\n\n    return {\n        uri: fileInUri,\n        absPath: pathWithoutFile,\n        relativePath: location,\n        startCol: startCol,\n        endCol: endCol\n    };\n};\n\nfunction createStatusBarItem() {\n    var statusBarItem = window.createStatusBarItem(vscode.StatusBarAlignment.Left);\n    statusBarItem.text = defaultIcon + defaultMsg;\n    statusBarItem.tooltip = 'List annotations';\n    statusBarItem.command = 'todohighlight.showOutputChannel';\n    return statusBarItem;\n};\n\nfunction errorHandler(err) {\n    window.processing = true;\n    setStatusMsg(defaultIcon, defaultMsg);\n    console.log('todohighlight err:', err);\n}\n\nfunction setStatusMsg(icon, msg, tooltip) {\n    if (window.statusBarItem) {\n        window.statusBarItem.text = `${icon} ${msg}` || '';\n        if (tooltip) {\n            window.statusBarItem.tooltip = tooltip;\n        }\n        window.statusBarItem.show();\n    }\n}\n\nfunction escapeRegExp(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nfunction escapeRegExpGroups(s) {\n    // Lookbehind assertions (\"(?<!abc) & (?<=abc)\") supported from ECMAScript 2018 and onwards. Native in node.js 9 and up.\n    if (parseFloat(process.version.replace('v', '')) > 9.0) {\n        let grpPattern = /(?<!\\\\)(\\()([^?]\\w*(?:\\\\+\\w)*)(\\))?/g;\n        // Make group non-capturing\n        return s.replace(grpPattern, '$1?:$2$3');\n    } else {\n        return escapeRegExpGroupsLegacy(s);\n    }\n}\n\nfunction escapeRegExpGroupsLegacy(s) {\n    return s.replace(/\\(\\?<[=|!][^)]*\\)/g, '') // Remove any unsupported lookbehinds\n        .replace(/((?:[^\\\\]{1}|^)(?:(?:[\\\\]{2})+)?)(\\((?!\\?[:|=|!]))([^)]*)(\\))/g, '$1$2?:$3$4'); // Make all groups non-capturing\n}\n\nmodule.exports = {\n    DEFAULT_STYLE,\n    getAssembledData,\n    chooseAnnotationType,\n    searchAnnotations,\n    annotationsFound,\n    createStatusBarItem,\n    setStatusMsg,\n    showOutputChannel,\n    escapeRegExp,\n    escapeRegExpGroups,\n    escapeRegExpGroupsLegacy\n};\n","module.exports = require(\"os\");","module.exports = require(\"vscode\");"],"sourceRoot":""}